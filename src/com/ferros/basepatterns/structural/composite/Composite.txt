Шаблон: Компоновщик (Composite)
=============================================================
Цель:

Скомпоновать объекты в структуру типа "дерева", позволяя клиенту единообразно
трактовать отдельные и составные объекты

===============================================================
Для чего используется:

Для группировки мелких компонентов в более крупные, которые в свою
очередь, могут стать основой для более крупных структур

===============================================================
Пример использования:

- для предоставления иерархии "часть-целое"
- мы хотим, чтобы клиент одним способом трактовал как отдельные, так и
составные объекты

===============================================================
Шаги Реализации:

1. Убедитесь, что вашу бизнес-логику можно представить как древовидную
 структуру. Попытайтесь разбить её на простые компоненты и контейнеры.
 Помните, что контейнеры могут содержать как простые компоненты, так и
 другие вложенные контейнеры.

2.  Создайте общий интерфейс компонентов, который объединит операции
   контейнеров и простых компонентов дерева. Интерфейс будет удачным,
   если вы сможете использовать его, чтобы взаимозаменять простые и
   составные компоненты без потери смысла.

3. Создайте класс компонентов-листьев, не имеющих дальнейших ответвлений.
   Имейте в виду, что программа может содержать несколько таких классов.

4.  Создайте класс компонентов-контейнеров и добавьте в него массив для
    хранения ссылок на вложенные компоненты. Этот массив должен быть
    способен содержать как простые, так и составные компоненты, поэтому
    убедитесь, что он объявлен с типом интерфейса компонентов.

   Реализуйте в контейнере методы интерфейса компонентов, помня о том,
   что контейнеры должны делегировать основную работу своим дочерним
   компонентам.

5. Добавьте операции добавления и удаления дочерних компонентов в класс
   контейнеров.

   Имейте в виду, что методы добавления/удаления дочерних компонентов
    можно поместить и в интерфейс компонентов. Да, это нарушит принцип
     разделения интерфейса, так как реализации методов будут пустыми в
      компонентах-листьях. Но зато все компоненты дерева станут
       действительно одинаковыми для клиента.
====================================================================
Преимущества

 +Упрощает архитектуру клиента при работе со сложным деревом компонентов.
 +Облегчает добавление новых видов компонентов.
 -Создаёт слишком общий дизайн классов.