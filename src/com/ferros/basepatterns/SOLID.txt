SOLID сформирован РОБЕРТОМ С.Мартином
================================================
S- Single Responsibility Principle
Принцип единой ответственности говорит о том что каждый клас должен иметь
ОДНУ ответственность

Цель
Разделить классы таким образом, что поломка одной логики не затронет другую
логику

Пример
нарушение В команде 1 специалист который выполняет все функции - если он заболел
рабочий процес сорван

Правильно:
В команде 4 специалиста, каждый из которых отвечает за свой участок. Если один
из них заболел, остановится только часть процесса
=====================================================

O -Open/Closed Principle
Принцип открытости-закрытости говорит о тои, что класс должен быть открыт
для расширения и закрыт для изменения

Цель
Добавить новую логику в класс, при этом не меняя существующую. Так как изменение
логики в большой системе может привести к некорректной работе зависимых компонентов

Пример
неправильно
Система работает с Redis. После рефакторинга логика работы с Redis Удалена,
и добавлена логика работы с MySQL
Правильно
Система работает с REdis. После рефакторинга логика работы с Redis неизменна\
и добавлена логика работы с MySQL
=======================================================
L - Liskov Substitution Principle
Принцип Барбары Лисков говорит о том, что если класс В являеться подклассом А,
то обьекты класса А могут быть заменены обьектами класса В, без нарушения
работоспособности системы

Цель
Сделать Родительские классы и классы наследники полносстью взаимозаменяемые
пример
Принцип подстановки — это ряд проверок, которые помогают
предсказать, останется ли подкласс совместим с остальным кодом
программы, который до этого успешно работал, используя объекты
базового класса. Это особенно важно при разработке библиотек и
фреймворков, когда ваши классы используются другими людьми, и
вы не можете повлиять на чужой клиентский код, даже если бы
хотели.
-Типы параметров метода подкласса должны совпадать или быть
боле абстрактными, чем типы параметров базового метода.
Довольно запутанно? Рассмотрим, как это работает на примере.
Базовый класс содержит метод feed(Cat c) , который умеет
кормить домашних котов. Клиентский код это знает и всегда
передаёт в метод кота.
Хорошо: Вы создали подкласс, и переопределили метод
кормёжки так, чтобы накормить любое животное:
feed(Animal c) . Если подставить этот подкласс в клиентский
код, то ничего страшного не произойдёт. Клиентский код
подаст в метод кота, но метод умеет кормить всех животных,
поэтому накормит и кота.
Плохо: Вы создали другой подкласс, в котором метод умеет
кормить только бенгальскую породу котов (подкласс котов):
feed(BengalCat t) . Что будет с клиентским кодом? Он всё так
же подаст в метод обычного кота. Но метод умеет кормить
только бенгалов, поэтому не сможет отработать, сломав
клиентский код.
-Тип возвращаемого значения метода подкласса должен
совпадать или быть подтипом возвращаемого значения
базового метода. Здесь всё то же, что и в предыдущем пункте, но
наоборот.
Базовый метод: buyCat(): Cat . Клиентский код ожидает на
выходе любого домашнего кота.
Хорошо: Метод подкласса: buyCat(): BengalCat . Клиентский
код получит бенгальского кота, который является домашним
котом, поэтому всё будет хорошо.
Плохо: Метод подкласса: buyCat(): Animal . Клиентский код
сломается, так как это непонятное животное (возможно,
крокодил) не поместится в ящике-переноске для кота.
Ещё один анти-пример, из мира языков с динамической
типизацией: базовый метод возвращает строку, а
переопределённый метод — число.
-Метод не должен выбрасывать исключения, которые не
свойственны базовому методу. Типы исключений в
переопределённом методе должны совпадать или быть
подтипами исключений, которые выбрасывает базовый метод.
Блоки try-catch в клиентском коде нацелены на конкретные
типы исключений, выбрасываемые базовым методом. Поэтому
неожиданное исключение, выброшенное подклассом, может
проскочить сквозь обработчики клиентского кода и обрушить
программу.
В большинстве современных языков программирования,
особенно строго типизированных (Java, C# и другие),
перечисленные ограничения встроены прямо в компилятор.
Поэтому вы попросту не сможете собрать программу,
нарушив их.
-Метод не должен ужесточать _пред_условия. Например, базовый
метод работает с параметром типа int. Если подкласс требует,
чтобы значение этого параметра к тому же было больше нуля, то
это ужесточает предусловия. Клиентский код, который до этого
отлично работал, подавая в метод негативные числа, теперь
сломается при работе с объектом подкласса.
-Метод не должен ослаблять _пост_условия. Например, базовый
метод требует, чтобы по завершению метода все подключения к
базе данных были бы закрыты, а подкласс оставляет эти
подключения открытыми, чтобы потом повторно использовать.
Но клиентский код базового класса ничего об этом не знает. Он
может завершить программу сразу после вызова метода, оставив
запущенные процессы-призраки в системе.
-Инварианты класса должны остаться без изменений. Инвариант
— это набор условий, при которых объект имеет смысл.
Например, инвариант кота — это наличие четырёх лап, хвоста,
способность мурчать и прочее. Инвариант может быть описан не
только явным контрактом или проверками в методах класса, но и
косвенно, например, юнит-тестами или клиентским кодом.
Этот пункт проще всего нарушить при наследовании, так как вы
можете попросту не подозревать о каком-то из условий
инварианта сложного класса. Идеальным в этом отношении был
бы подкласс, который только вводит новые методы и поля, не
прикасаясь к полям базового класса.
-Подкласс не должен изменять значения приватных полей
базового класса. Этот пункт звучит странно, но в некоторых
языках доступ к приватным полям можно получить через
механизм рефлексии. В некоторых других языках (Python,
JavaScript) и вовсе нет жёсткой защиты приватных полей.


Выпускник Курсов не может написать сложные SQL запросы, но может написать калькулятор
В случае отсутствия SDE на рабочем месте, выпускник не сможет написать сложный запрос

Правильно
Выпускник курсов, являясь разработчиком может писать сложные SQL запросы и может
написать калькулятор. Сложный SQL Запрос может быть написан и в случае отсутствия
SDE на рабочем месте.
================================================================

I - Interface Segregation Principle

Принцип разделения интерфейсов говорит о том, что много уточненых интерфейсов
лучше лем один общий и громоздкий интерфейс

Цель
Сделать такой набор интерфейсов, который позволит классам реализовать только
действительно необходимое поведение

Нарушение
Все разрабртчики обязаны владеть такими навыками "ТЫ ж ПРОГРАМИСТ", что требует
имплементировать для BACK_END_DEV и MOBILE_APP_DEV поведение, которое к ним не
относиться

Правильно
Выделение 3 основные группы навыков для BACK_END_DEV и MOBILE_APP_DEV и SYSTEM_ADMIN
Это позволяет выделить необходимое поведение. И даже когда появиться "ТЫ ж ПРОГРАМИСТ"
он сможет легко имплементировать все необходимые навыки
=====================================================================

D - Dependency Inversion Principle

Принцип инверсии зависимостей говорит о том, что модули верхних уровней не
должны импортировать элеоменты нижних, а абстракции не должны зависеть от
от деталей(именно детали должны зависеть от абстракций)

Пример
неправильно
Разработчик умеет писать код в IDE Net Beans. Его возможность писать код
(абстракция) связана с конкретной IDE(детали). Что делает невозможным легкую
замену среды разработки(деталей)
привильно
Разработчик умеет писать код(абстракция). Ив этой абстракции мы никак не связаны
сосредой разработки(деталями). Что позволит легко заменить IDE на любую другую,
не затронув основне поведение
