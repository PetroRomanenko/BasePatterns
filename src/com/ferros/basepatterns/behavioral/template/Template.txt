Шаблон: Шаблонный метод (Template)
=============================================================
Цель:

Определение зависимости "Один ко многоим " между обьектами

===============================================================
Для чего используется:

Определение зависимости "один ко многим" между обьектми таким образом, что
при изменения состояния одного обьекта все зависимые от него обьекты были
увемедлены об этом событии

===============================================================
Пример использования:

- когдау модели имеется два аспекта, один из которых зависит от другого.
инкапсулирование этих аспектов в разные классы позволяет использовать их
независимодруг от друга
-когда один обьект должен оповещать дургие и не делать предположений об
этих обьектах
- ослабление связи между обьектами
===============================================================
Шаги Реализации:

1. Разбейте вашу функциональность на две части: независимое ядро и опциональные зависимые части. Независимое ядро станет издателем. Зависимые части станут подписчиками.

   Создайте интерфейс подписчиков. Обычно в нём достаточно определить единственный метод оповещения.

   Создайте интерфейс издателей и опишите в нём операции управления подпиской. Помните, что издатель должен работать только с общим интерфейсом подписчиков.

   Вам нужно решить, куда поместить код ведения подписки, ведь он обычно бывает одинаков для всех типов издателей. Самый очевидный способ — вынести этот код в промежуточный абстрактный класс, от которого будут наследоваться все издатели.

   Но если вы интегрируете паттерн в существующие классы, то создать новый базовый класс может быть затруднительно. В этом случае вы можете поместить логику подписки во вспомогательный объект и делегировать ему работу из издателей.

   Создайте классы конкретных издателей. Реализуйте их так, чтобы после каждого изменения состояния они отправляли оповещения всем своим подписчикам.

   Реализуйте метод оповещения в конкретных подписчиках. Не забудьте предусмотреть параметры, через которые издатель мог бы отправлять какие-то данные, связанные с происшедшим событием.

   Возможен и другой вариант, когда подписчик, получив оповещение, сам возьмёт из объекта издателя нужные данные. Но в этом случае вы будете вынуждены привязать класс подписчика к конкретному классу издателя.

   Клиент должен создавать необходимое количество объектов подписчиков и подписывать их у издателей.

====================================================================
Преимущества и недостатки
